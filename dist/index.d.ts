import type { Builder } from "./Builder.js";
import type { Cast } from "./types/Cast.js";
import type { Collate } from "./types/Collate.js";
import type { Expression, MathOperator } from "./types/Expression.js";
import type { Falseable } from "./types/Falseable.js";
import type { Identifier } from "./types/Identifier.js";
import type { JsonValue } from "./types/JsonValue.js";
import type { Value } from "./types/Value.js";
import type { ValueExtended } from "./types/ValueExtended.js";
import { BuilderCase } from "./BuilderCase";
import { BuilderConflict } from "./BuilderConflict";
import { BuilderDelete } from "./BuilderDelete";
import { BuilderInsert } from "./BuilderInsert";
import { BuilderSelect } from "./BuilderSelect";
import { BuilderSetOperation } from "./BuilderSetOperation";
import { BuilderUpdate } from "./BuilderUpdate";
import { call, customCall } from "./supports/SqliteFunctions";
declare const functions: {
    and(...expressions: Array<Falseable<Expression>>): Expression;
    between(identifier: Identifier, from: Expression, to: Expression): Expression;
    call: typeof call;
    case(expression?: Expression): BuilderCase;
    cast(expression: Expression, castType: Cast): Expression;
    collate(expression: Expression, collateType?: Collate): Expression;
    customCall: typeof customCall;
    delete(table: Identifier): BuilderDelete;
    eq(sideA: Expression, sideB: Expression): Expression;
    exists(builder: Builder): Expression;
    gt(sideA: Expression, sideB: Expression): Expression;
    gte(sideA: Expression, sideB: Expression): Expression;
    isNull(identifier: Identifier): Expression;
    insert(table: Identifier, columns: Identifier[]): BuilderInsert;
    isNotNull(identifier: Identifier): Expression;
    jsonValue(argument: JsonValue, nullAsSQL?: boolean): Expression;
    jsonStaticValue(argument: JsonValue, nullAsSQL?: boolean): Expression;
    lt(sideA: Expression, sideB: Expression): Expression;
    lte(sideA: Expression, sideB: Expression): Expression;
    neq(sideA: Expression, sideB: Expression): Expression;
    not(expression: Expression): Expression;
    notBetween(identifier: Identifier, from: Expression, to: Expression): Expression;
    or(...expressions: Array<Falseable<Expression>>): Expression;
    raw(expression: string): Expression;
    select(...columns: Array<Falseable<Expression>>): BuilderSelect;
    staticValue(argument: ValueExtended): Expression;
    union(...queries: Expression[]): BuilderSetOperation;
    unionAll(...queries: Expression[]): BuilderSetOperation;
    intersect(...queries: Expression[]): BuilderSetOperation;
    except(...queries: Expression[]): BuilderSetOperation;
    update(table: Identifier): BuilderUpdate;
    conflict(columns?: Identifier[], where?: Expression): BuilderConflict;
    excluded(identifier: Identifier): Expression;
    value(argument: Value): Expression;
    op(operator: MathOperator, expressionA: Expression, expressionB: Expression): Expression;
    sum(expressionA: Expression, expressionB: Expression): Expression;
    sub(expressionA: Expression, expressionB: Expression): Expression;
    mul(expressionA: Expression, expressionB: Expression): Expression;
    div(expressionA: Expression, expressionB: Expression): Expression;
    mod(expressionA: Expression, expressionB: Expression): Expression;
    pow(expressionA: Expression, expressionB: Expression): Expression;
};
export default functions;
