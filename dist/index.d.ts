import type { Builder } from "./Builder.js";
import type { Cast } from "./types/Cast.js";
import type { Collate } from "./types/Collate.js";
import type { Expression } from "./types/Expression.js";
import type { Falseable } from "./types/Falseable.js";
import type { Identifier } from "./types/Identifier.js";
import type { JsonValue } from "./types/JsonValue.js";
import type { Value } from "./types/Value.js";
import type { ValueExtended } from "./types/ValueExtended.js";
import { BuilderDelete } from "./BuilderDelete";
import { BuilderInsert } from "./BuilderInsert";
import { BuilderSelect } from "./BuilderSelect";
import { BuilderUpdate } from "./BuilderUpdate";
import { call, customCall } from "./supports/SqliteFunctions";
declare const functions: {
    and(...expressions: Array<Falseable<Expression>>): Expression;
    between(identifier: Identifier, from: Expression, to: Expression): Expression;
    call: typeof call;
    cast(expression: Expression, castType: Cast): Expression;
    collate(expression: Expression, collateType?: Collate): Expression;
    customCall: typeof customCall;
    delete(table: Identifier): BuilderDelete;
    eq(sideA: Expression, sideB: Expression): Expression;
    exists(builder: Builder): Expression;
    gt(sideA: Expression, sideB: Expression): Expression;
    gte(sideA: Expression, sideB: Expression): Expression;
    isNull(identifier: Identifier): Expression;
    insert(table: Identifier, columns: Identifier[]): BuilderInsert;
    isNotNull(identifier: Identifier): Expression;
    jsonValue(argument: JsonValue): Expression;
    lt(sideA: Expression, sideB: Expression): Expression;
    lte(sideA: Expression, sideB: Expression): Expression;
    neq(sideA: Expression, sideB: Expression): Expression;
    not(expression: Expression): Expression;
    notBetween(identifier: Identifier, from: Expression, to: Expression): Expression;
    or(...expressions: Array<Falseable<Expression>>): Expression;
    raw(expression: string): Expression;
    select(...columns: Array<Falseable<Expression>>): BuilderSelect;
    staticValue(argument: ValueExtended): Expression;
    update(table: Identifier): BuilderUpdate;
    value(argument: Value): Expression;
};
export default functions;
